// Code generated by protoc-gen-go, but edited for golang.org/x/tools/go/analysis/analysistest
// which can't import external packages
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: one_of/oneof.proto

package one_of

type A struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

type B struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

type Msg struct {
	// Types that are valid to be assigned to Payload:
	//
	//	*Msg_A
	//	*Msg_B
	Payload isMsg_Payload `protobuf_oneof:"payload"`
}

func (x *Msg) GetPayload() isMsg_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Msg) GetA() *A {
	if x != nil {
		if x, ok := x.Payload.(*Msg_A); ok {
			return x.A
		}
	}
	return nil
}

func (x *Msg) GetB() *B {
	if x != nil {
		if x, ok := x.Payload.(*Msg_B); ok {
			return x.B
		}
	}
	return nil
}

type isMsg_Payload interface { //want isMsg_Payload:`one_of\.Msg_A,one_of\.Msg_B`
	isMsg_Payload()
}

type Msg_A struct {
	A *A `protobuf:"bytes,1,opt,name=a,proto3,oneof"`
}

type Msg_B struct {
	B *B `protobuf:"bytes,2,opt,name=b,proto3,oneof"`
}

func (*Msg_A) isMsg_Payload() {}

func (*Msg_B) isMsg_Payload() {}

func process(msg *Msg) {
	switch msg.GetPayload().(type) { // want `non-exhaustive type switch on isMsg_Payload: missing cases for: one_of.Msg_B`
	case *Msg_A:
	default:
	}
}
